\documentclass[a4paper, 11pt]{article}
\usepackage{comment} % enables the use of multi-line comments (\ifx \fi) 
\usepackage{fullpage} % changes the margin
\usepackage[linesnumbered,ruled,french, onelanguage,vlined]{algorithm2e}
\RestyleAlgo{boxruled}
\usepackage{amsmath}
\usepackage[makeroom]{cancel}


\SetKwIF{Si}{SinonSi}{}{Si}{}{Sinon}{}{Fin}

\SetKwFor{Pour}{Pour}{}{Fin}

\begin{document}
\noindent
\large\textbf{Mini-Projet C++} \hfill \textbf{RIBER Rafael} \\
\large\textbf{ColoReduce}\\
\normalsize ICC Pratique - CS-119\\
\hfill Novembre - Décembre 2018

\section*{Phase d'analyse}
Decrire l’organisation generale du programme en faisant ressortir la mise en oeuvre des principes d’abstraction et de re-utilisation.\\

Le programme est divisé en 5 fonctions de lecture regroupées sous \texttt{fileRead()}, 4 fonctions de transformation, et 2 fonctions de rendu:

Au sein de la fonction \texttt{fileRead}, executée dans \texttt{main} et qui regroupe les autres fonctions de lecture du fichier d'entrée, on crée tout d'abord une strucure \texttt{"image"} de type \texttt{InputImg} qui stockera toutes les informations du fichier d'entrée nécessaires dans des champs facilement accessibles. 
On execute ensuite dans \texttt{fileRead} les fonctions \texttt{inputReduced, inputThresholds, inputFilters, inputDimensions} et \texttt{inputPixels} qui remplissent chacune un champ de cette structure qui leur est passée par référence, respectivement le nombre et les valeurs des couleurs réduites, les valeurs des seuils, le nombre de filtres, les dimensions \texttt{nbL} et \texttt{nbC}, et les différentes couleurs des pixels de l'image à traiter, tout en vérifiant la validité de ces données et en renvoyant des erreurs en cas d'une mauvaise valeur. Le résultat de cette lecture est stocké dans la structure de type \texttt{InputImg} appelée \texttt{image}.\\

Cette structure est ensuite passée à la première fonction de transformation, appelée \texttt{normalize}, qui crée un tableau de type \texttt{NormImg} appelé \texttt{norm}, et calcule 

\newpage
\section*{Algorithme de filtrage}

\begin{algorithm}[H]
\SetSideCommentLeft
    \KwIn{Image normalisée $N$ de taille $C \times L$, nombre de filtres à appliquer $f$, nombre de couleurs réduites de l'image $r$.}
    \KwResult{Image N filtrée $f$ fois\\
    \textbf{Remarque: }Les coordonnées de l'image ainsi que les listes sont ici indexées à 0.\\\hrulefill}
    
    %\underline{Filtrage}$(N,x,y,f,r)$\
    $copie \gets N$\\
    $val \gets 0$\\
    $count$ est une liste de longueur fixe $r$.
    
    \Pour{$n$ \upshape{de} $0$ \upshape{à} $f$}
      {
      	\Pour{$x$ \upshape{de} $1$ \upshape{à} $C - 1$}
      	  {
      	  \Pour{$y$ \upshape{de} $1$ \upshape{à} $L - 1$}
      	    {
    			$current \gets 0$\\
   				\Pour{$i$ \upshape{de} $-1$ \upshape{à} $1$}
   				  {
   				  	\Pour{$j$ \upshape{de} $-1$ \upshape{à} $1$}
   				  	  {
   				  	  	\Si{$i \neq 0$ \upshape{ou} $j \neq 0$}
   				  	  	  {
   				  	  	    $current \gets copy$[$x + i$][$y + j$]\\
   				  	  	  	\Pour{$c$ \upshape{de} $0$ \upshape{à} $r$}
   				  	  	  	  {
   				  	  	  	  	\Si {$c = current$}
   				  	  	  	  		{
   				  	  	  	  			$count$[$c$] = $count$[$c$]$ + 1$\\
   				  	  	  	  			\Si {$count$\upshape{[$c$]} $\geq 6$}
   				  	  	  	  			  {
   				  	  	  	  			    $val \gets c$\\
   				  	  	  	  			    Continuer à la ligne 20.
   				  	  	  	  			  }
   				  	  	  	  			\SinonSi{}{$val \gets 0$}
   				  	  	  	  		}
   				  	  	  	  }
   				  	  	  }
   				  	  }
   				  }
             $N$[$x$][$y$] $\gets val$
      	    }
      	  }
      	  $copie \gets N$
        }
        \Si{$f > 0$} 
          {
        	\Pour{$i$ \upshape{de} $0$ \upshape{à} $L$} 
        	{
        	  \Pour{$j$ \upshape{de} $0$ \upshape{à} $C$}
        	  {
                \Si{$i = 0$ \upshape{ou} $j = 0$ \upshape{ou} $i = L - 1$ \upshape{ou} $j = C - 1$}
                  {
                    $N$[$i$][$j$] $\gets 0$
                  }
              }
            }
        }
       \textbf{Sortir} $N$
\caption{ \textsc{Filtrage}}
\end{algorithm}

\section*{Analyse de complexité}
Dans le pire des cas, on parcourt tous les pixels n'étant pas en bordure de l'image $f$ fois, en parcourant une liste de longueur $r$ pour chacun des 8 voisins d'un pixel, puis les pixels de bordure une seule fois.

On a donc $N_i = (c - 2)(l-2)$ pixels à filtrer $f$ fois, et $N_b = (2c + 2(l-2))$ pixels en bordure, le tout multiplié par le nombre maximum de couleurs réduites $r_{max} = 255$ que l'on parcourt 8 fois pour les pixels voisins, ce qui donne:
%&= 8 \cdot r_{max} \bigg(f \cdot (c - 2)(l-2) + (2c + 2(l-2))\bigg) \nonumber \\
% &= 8 \cdot r_{max}\bigg((fcl-2fc-2fl+4f) + (2c+2l-4)\bigg)\nonumber \\
%&= 8 \cdot r_{max}\bigg(flc - 2fc - 2fl + 4f + 2c\bigg) \nonumber \\
$$N_{pixels} = 8 \cdot r_{max} \bigg(f \cdot N_i + N_b \bigg)
= 8 \cdot \underbrace{r_{max}\underbrace{\bigg(flc - f \cdot \bigg(2c + 2l - 4 - \frac{2c}{f}\bigg)\bigg)}_{\leq f\cdot l\cdot c}}_{\leq r_{max} \cdot f\cdot l\cdot c} \leq 8\cdot rflc$$
Et donc: $$N_{pixels} \leq 8\cdot rflc$$

On a ainsi une complexité de $\mathcal{O}(N_{pixels}) \leq \mathcal{O}(8\cdot r\cdot f\cdot l\cdot c)$, et donc une complexité de type $\mathcal{O}(?????????????????)$.
\end{document}