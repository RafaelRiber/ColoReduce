\documentclass[a4paper, 11pt]{article}
\usepackage{comment} % enables the use of multi-line comments (\ifx \fi) 
\usepackage{fullpage} % changes the margin
\usepackage[linesnumbered,ruled,french, onelanguage,vlined]{algorithm2e}
\RestyleAlgo{boxruled}
\usepackage{amsmath}
\usepackage[makeroom]{cancel}

\usepackage{graphicx}

\usepackage[]{textcomp}

\usepackage{geometry}
 \geometry{
 a4paper,
 left=15mm,
 right=15mm,
 top=15mm,
 }


\SetKwIF{Si}{SinonSi}{}{Si}{}{Sinon}{}{Fin}

\SetKwFor{Pour}{Pour}{}{Fin}

\begin{document}
\noindent
\large\textbf{Mini-Projet C\raisebox{.5\height}{\scalebox{.5}{++}}} \hfill \textbf{RIBER Rafael} \\
\large\textbf{ColoReduce}\hfill \textbf{EL-BA1}\\
\normalsize ICC Pratique - CS-119\\
\hfill Novembre - Décembre 2018

\section*{Phase d'analyse}
Le programme est divisé en 5 fonctions de lecture regroupées sous \texttt{fileRead()}, 4 fonctions de transformation, et 2 fonctions de rendu:
\subparagraph{\textit{Lecture:}}
Au sein de la fonction \texttt{fileRead}, executée dans \texttt{main}, on commence par déclarer une structure \texttt{"input"} de type \texttt{InputImg}. On execute ensuite les fonctions \texttt{inputReduced, inputThresholds, inputFilters, inputDimensions} et \texttt{inputPixels} qui remplissent chacune un champ de cette structure qui leur est passée par référence, respectivement le nombre \texttt{nbR} et les valeurs des couleurs réduites, les valeurs des seuils, le nombre de filtres \texttt{nbF}, les dimensions \texttt{nbL} et \texttt{nbC}, et les différentes couleurs des pixels de l'image à traiter, tout en vérifiant la validité de ces données et en renvoyant des erreurs en cas d'une mauvaise valeur. Le résultat de cette lecture est stocké dans la structure de type \texttt{InputImg} appelée \texttt{"image"} au sein de la fonction \texttt{main}.

\subparagraph{\textit{Seuillage:}}
Cette structure est ensuite passée par référence à la première fonction de transformation executée dans \texttt{main} appelée \texttt{normalize}, qui crée un tableau de type \texttt{NormImg} appelé \texttt{"normOut"}, calcule pour chaque pixel son intensité normalisée $I_N$ à partir des intensités RVB de ce dernier et détermine ensuite le code couleur de chaque pixel selon la valeur de cette intensité, ainsi que les seuils et la liste de couleurs réduites donnés en entrée. Le résultat de cette opération est stocké au sein de \texttt{main} dans un tableau \texttt{"norm"} de type \texttt{NormImg}.

\subparagraph{\textit{Filtrage:}} On passe par référence à la fonction \texttt{filter} le tableau \texttt{"norm"}, ainsi que les dimensions de l'image d'entrée, le nombre \texttt{nbF}, et le nombre \texttt{nbR}. Pendant l'opération de filtrage (dans la fonction \texttt{filter}), la fonction \texttt{getPixelValue} calcule la nouvelle valeur de chaque pixel selon la valeur des pixels voisins. Le tableau est modifié par référence et l'image filtrée se trouve ainsi dans le tableau \texttt{"norm"} à la fin des \texttt{nbF} filtrages. La fonction \texttt{blackEdge}, executée au sein de \texttt{filter} après les filtrages, applique un bord noir d'un pixel de largeur tout autour de l'image filtrée, si \texttt{nbF} $> 0$.

\subparagraph{\textit{Rendu et fin:}} La fonction \texttt{render} génère un tableau \texttt{RGBImg} de structures de type \texttt{Color} contenant les valeurs RVB de chaque pixel à partir de l'indice entier calculé durant le seuillage et le filtrage ainsi que la couleur à l'indice correspondant dans la liste de couleurs réduites donnée en entrée. Le résultat est stocké dans le tableau \texttt{"rendered"} de type \texttt{RBGImg}.

La fonction \texttt{printRGB} affiche dans le terminal le tableau \texttt{rendered}, en ajoutant l'en-tête "P3" et en imprimant des espaces entre les valeurs RVB successives, ainsi que des retours à la ligne après chaque ligne de l'image.

\newpage
\section*{Algorithme de filtrage}

\begin{algorithm}[H]
\SetSideCommentLeft
    \KwIn{Image normalisée $N$ de taille $C \times L$, nombre de filtres à appliquer $f$, nombre de couleurs réduites de l'image $r$.}
    \KwResult{Image N filtrée $f$ fois\\
    \textbf{Remarque: }Les coordonnées de l'image ainsi que les listes sont ici indexées à 0.\\\hrulefill}
    
    %\underline{Filtrage}$(N,x,y,f,r)$\
    $copie \gets N$\\
    $val \gets 0$\\
    $count$ est une liste de longueur fixe $r$.
    
    \Pour{$n$ \upshape{de} $0$ \upshape{à} $f$}
      {
      	\Pour{$x$ \upshape{de} $1$ \upshape{à} $C - 1$}
      	  {
      	  \Pour{$y$ \upshape{de} $1$ \upshape{à} $L - 1$}
      	    {
    			$current \gets 0$\\
   				\Pour{$i$ \upshape{de} $-1$ \upshape{à} $1$}
   				  {
   				  	\Pour{$j$ \upshape{de} $-1$ \upshape{à} $1$}
   				  	  {
   				  	  	\Si{$i \neq 0$ \upshape{ou} $j \neq 0$}
   				  	  	  {
   				  	  	    $current \gets copy$[$x + i$][$y + j$]\\
   				  	  	  	\Pour{$c$ \upshape{de} $0$ \upshape{à} $r$}
   				  	  	  	  {
   				  	  	  	  	\Si {$c = current$}
   				  	  	  	  		{
   				  	  	  	  			$count$[$c$] = $count$[$c$]$ + 1$\\
   				  	  	  	  			\Si {$count$\upshape{[$c$]} $\geq 6$}
   				  	  	  	  			  {
   				  	  	  	  			    $val \gets c$\\
   				  	  	  	  			    Continuer à la ligne 20.
   				  	  	  	  			  }
   				  	  	  	  			\SinonSi{}{$val \gets 0$}
   				  	  	  	  		}
   				  	  	  	  }
   				  	  	  }
   				  	  }
   				  }
             $N$[$x$][$y$] $\gets val$
      	    }
      	  }
      	  $copie \gets N$
        }
        \Si{$f > 0$} 
          {
        	\Pour{$i$ \upshape{de} $0$ \upshape{à} $L$} 
        	{
        	  \Pour{$j$ \upshape{de} $0$ \upshape{à} $C$}
        	  {
                \Si{$i = 0$ \upshape{ou} $j = 0$ \upshape{ou} $i = L - 1$ \upshape{ou} $j = C - 1$}
                  {
                    $N$[$i$][$j$] $\gets 0$
                  }
              }
            }
        }
       \textbf{Sortir} $N$
\caption{ \textsc{Filtrage}}
\end{algorithm}

\section*{Analyse de complexité}
Dans le pire des cas, on parcourt tous les pixels n'étant pas en bordure de l'image $f$ fois, en parcourant une liste de longueur $r$ pour chacun des 8 voisins d'un pixel, puis les pixels de bordure une seule fois.

On a donc $N_i = (c - 2)(l-2)$ pixels à filtrer $f$ fois, et $N_b = (2c + 2(l-2))$ pixels en bordure, le tout multiplié par le nombre maximum de couleurs réduites $r_{max} = 255$ que l'on parcourt 8 fois pour les pixels voisins, ce qui donne:
%&= 8 \cdot r_{max} \bigg(f \cdot (c - 2)(l-2) + (2c + 2(l-2))\bigg) \nonumber \\
% &= 8 \cdot r_{max}\bigg((fcl-2fc-2fl+4f) + (2c+2l-4)\bigg)\nonumber \\
%&= 8 \cdot r_{max}\bigg(flc - 2fc - 2fl + 4f + 2c\bigg) \nonumber \\
%$$N_{pixels} = 8 \cdot r_{max} \bigg(f \cdot N_i + N_b \bigg)
%= 8 \cdot \underbrace{r_{max}\underbrace{\bigg(flc - f \cdot \bigg(2c + 2l - 4 - \frac{2c}{f}\bigg)\bigg)}%_{\leq f\cdot l\cdot c}}_{\leq r_{max} \cdot f\cdot l\cdot c} \leq 8\cdot rflc$$
%Et donc: $$N_{pixels} \leq 8\cdot rflc$$

%On a ainsi une complexité de $\mathcal{O}(N_{pixels}) \leq \mathcal{O}(8\cdot r\cdot f\cdot l\cdot c)$, et %donc une complexité de type $\mathcal{O}(?????????????????)$.
\end{document}